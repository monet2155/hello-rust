## 열거형

Rust에서는 구조체로만 커스텀 타입을 만들 수 있는 것은 아니다.

열거형(enumerations, 줄여서 enums)은 하나의 타입이 가질 수 있는 배리언트(variant)들을 열거함으로 타입을 정의할 수 있도록 한다.

우선 직접 열거형을 정의해보고, 특히 유용하게 사용되는 열거형인 `Option`을 살펴본다. 마지막으로 열거형을 간결하게 다루기 위한 관용 표현인 `if let` 구문을 학습한다.

## 열거형 정의하기

구조체가 서로 연관된 필드 및 데이터를 묶는다면, 열거형은 어떤 값이 여러 개의 가능한 값의 집합 중 하나라는 것을 나타낸다.

예를 들어, `Rectangle`이 `Circle`이나 `Triangle`를 포함하는 다양한 모형들의 집합 중 하나라고 표현하고 싶다면, 열거형으로 나타낼 수 있을 것이다.

---

IP 주소를 다루는 프로그램을 작성하면서, 열거형이 어떤 상황에서 구조체보다 적절할 지 알아보도록 하자.

현재 IP 주소 표준은 IPv4와 IPv6로, 샘플 프로그램에서도 이 두 종류만 구현한다.

IP 주소가 반드시 v4 또는 v6로 나눠지게 되는 특성은 열거형에 적합하다.

`IpAddrKind` 라는 열거형을 정의해보자.

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

위 코드에서 `V4`, `V6`가 열거형의 배리언트가 되며, 이제 `IpAddrKind`는 코드 어디서든 사용할 수 있는 커스텀 데이터 타입이 된다.

### 열거형 값

`IpAddrKind`의 배리언트에 대한 인스턴스는 아래와 같이 생성한다.

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

또 우리는 `IpAddrKind` 타입을 인수로 받는 함수를 정의하고, 배리언트를 사용해서 함수를 호출할 수도 있다.

```rust
fn route(ip_kind: IpAddrKind) {}

route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

---

열거형을 사용하면 더 많은 이점이 있다.

현재로서는 IP 종류를 구별할 수만 있기 때문에, 구조체를 사용하여 해결하고 싶을 수 있다.

```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};
```

위 코드는 IP의 종류를 나타내는 열거형 `IpAddrKind`와 이를 타입으로 하는 `kind` 변수를 지닌 `IpAddr` 구조체를 정의했다.

이렇게 하면 `IpAddr` 구조체를 통해 해당 IP의 종류와 주소를 가지며 연관된 값임을 인지할 수 있다.

Rust에서 열거형은 이보다 더 간결한 방법을 제공한다. 열거형 배리언트에 데이터를 직접 넣을 수 있다.

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
```

열거형의 각 배리언트에 직접 데이터를 붙여 구조체를 사용할 필요가 없어졌다.

또한 열거형 동작에 대해 살펴보기 쉬워졌다. 배리언트의 이름이 열거형 인스턴스 생성자 함수처럼 된다.

즉, `IpAddr::V4()`는 `String` 인수를 입력받아 `IpAddr` 타입의 인스턴스를 반환하는 함수가 된다. (열거형을 정의한 결과로 이러한 생성자 함수가 자동적으로 정의된다.)

---

구조체 대신 열거형을 사용하면 또 다른 장점이 있다.

배리언트는 각각 다른 타입의 데이터를 가질 수 있게 된다.

예를 들어, `V4` 주소는 항상 0 ~ 255 사이의 숫자 4개를 가진다. 반면 `V6` 주소는 하나의 `String` 값으로 표현되길 원할 수 있다.

이 요구사항은 위 코드 중 열거형과 구조체를 혼합한 방식으로는 구현할 수 없다. (구조체만 사용한다고 해도 불가능하다.)

열거형은 이 경우를 쉽게 처리한다.

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

---

우리는 열거형을 정의해서 두 가지의 IP 주소를 저장하는 방법을 알아보았다.

IP 주소와 그 종류를 저장하는 것은 자주 사용되는 기능이기에, 표준 라이브러리에도 정의되어 있다.

우리는 이제 표준 라이브러리에서 `IpAddr` 가 어떻게 정의되었는지 알아보자.

```rust
struct Ipv4Addr {
    // ...
}

struct Ipv6Addr {
    // ...
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}

```

우리가 직접 정의한 열거형과 비슷한 형태를 띄고있지만, 각 배리언트가 같는 데이터는 각각의 구조체 타입(`Ipv4Addr`, `Ipv6Addr`)으로 정의되어 있다.

이 코드로 알 수 있듯, 열거형 배리언트에는 어떤 종류의 데이터든 넣을 수 있다.

문자열, 숫자, 구조체, 심지어는 다른 열거형을 넣을 수 있다.

(현재 스코프에 표준 라이브러리를 가져오지 않기 때문에 `IpAddr`라는 이름의 타입이 정의 가능했다. 타입을 스코프로 가져오는 것은 7장에서 학습한다.)

---

이번엔 다른 열거형 예제를 살펴보자. 각 배리언트에 다양한 종류의 타입이 포함되어 있다.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

이 열거형은 서로 다른 데이터 타입을 갖는 네 개의 배리언트가 존재한다.

- `Quit`은 연관된 데이터를 가지지 않는다.
- `Move`는 구조체처럼 이름이 있는 필드를 가진다.
- `Write`는 하나의 `String`을 가진다.
- `ChangeColor`는 세 개의 `i32`를 가진다.

`Message` 처럼 다양한 배리언트로 열거형을 정의하는 것은 각각의 구조체들을 정의하는 것과 비슷하다.

```rust
struct QuitMessage;
struct MoveMessage {
    x: i32,
    y: i32,
};
struct WriteMessage(String);
struct ChangeColorMessage(i32, i32, i32)l
```

이처럼 각각 다른 타입이 되는 여러 개의 구조체를 사용한다면, 이 메시지 중 어떤 한 가지를 인수로 받는 함수를 정의하기 어려울 것이다.

`Message`와 같은 열거형을 사용한다면 이러한 함수를 정의할 수 있게 된다.

```rust
impl Message {
    fn call(&self) {
        // ...
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

이렇게 `Message` 중 한 가지로 인스턴스를 생성하고, 공통되는 함수를 호출할 수 있게 된다.

```
* 개인 의견 *
객체지향의 다형성같은 느낌이 많이 든다.
```

---

### Option 열거형

표준 라이브러리에서 열거형으로 정의된 또 다른 타입인 `Option`에 대해 알아보자.

`Option` 타입은 값이 있거나 없을 수 있는 아주 흔한 상황을 나타낸다.

Rust에는 널(null) 개념이 존재하지 않는다.

그러나 "유효하지 않거나, 존재하지 않는 값"이라는 개념은 필요하기 때문에, Rust에서는 값의 존재 혹은 부재를 표현할 수 있는 열거형이 존재한다.

그 열거형이 바로 `Option<T>` 이며, 아래와 같이 정의되어 있다.

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` 열거형은 유용하기 때문에 Rust에서 기본으로 임포트하는 `Prelude`에도 포함되어 있다.

(심지어 배리언트 또한 포함되어 있기에 `Some`과 `None` 앞에 `Option::` 을 붙이지 않아도 된다.)

`<T>`는 아직 학습하지 않은 문법이다. 제네릭 타입 매개변수(Generic type parameter)이며, 10장에서 자세히 학습한다.

일단은 `<T>`라는 것이 `Option` 열거형의 `Some` 배리언트에 어떤 타입의 데이터든 담을 수 있게 설정한다는 것, 그리고 `T`에 구체적인 타입을 집어넣으면 각각의 `Option<T>` 타입이 모두 다른 타입이 된다는 점을 기억하면 된다.

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

위는 다양한 타입을 갖는 `Option` 값에 대한 예시이다.

`some_number`와 `some_char`의 타입이 서로 다르다는 것은 `Some` 배리언트에 값을 명시했기 때문에 Rust가 스스로 이 타입을 추론할 수 있다.

`absent_number`는 타입을 명시해야한다. 컴파일러는 `None` 값만 보고 실제로 `Some` 배리언트가 어떤 타입의 값을 가질 지 추론할 수 없기 때문이다.

이제 우리는 `Some` 값을 얻었을 때, 값이 존재함과 동시에 값 자체를 얻을 수 있다. `None` 값을 얻으면 값이 유효하지 않다는 것을 알 수 있다.

`Option<T>`가 널 개념보다 나은 이유는 무엇일까?

간단하게 말하면, `Option<T>`와 `T`는 다른 타입이므로, 컴파일러는 `Option<T>`를 일반 값처럼 사용하지 못하도록 한다.

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

위 코드를 실행하면 아래와 같은 에러가 출력된다.

```
...
no implementation for `i8 + Option<i8>`
...
```

이 메시지는 Rust가 `i8` 타입과 `Option<i8>` 타입간의 더하기 연산을 이해하지 못하기 때문이다.

Rust 컴파일러는 `i8`과 같은 일반 타입의 값을 가질 때 항상 유효함을 보장한다. 그러나 `Option<T>` 는 값이 있을지 없을지 알 수 없다.

---

위 연산을 수행하기 위해 우리는 `Option<T>`를 `T`로 변환해야한다. 이러한 방식은 널 개념을 사용할때 발생하는, 널인데 널이 아니라고 가정하는 상황을 발견하는데 도움이 된다.

널일 수 있는 값을 사용하려면 (변수에 담으려면) 명시적으로 타입을 `Option<T>`로 지정하고, 이 값을 사용할때 명시적으로 처리해주어야 한다.

이렇게 하면 `Option<T>` 가 아닌 모든 타입은 값이 널이 아니라고 안전하게 가정할 수 있으며, Rust 코드의 안정성을 높이기 위해 의도된 Rust 디자인 결정 사항이다.

---

`Option<T>` 타입에는 많은 메서드가 존재하며, 다양한 상황에서 유용하게 사용될 수 있으니 익혀두면 도움이 될 것이다. [공식 문서](https://doc.rust-lang.org/std/option/enum.Option.html)

일반적으로 `Option<T>` 값을 사용하기 위해 각 배리언트를 처리할 코드가 필요할 것이다.

`Some` 배리언트 일때만 실행되어 `T` 값을 사용하거나, `None`일 때 (값이 없는 경우) 처리할 코드도 필요하다.

`match` 표현식은 열거형과 함께 사용할 때 이러한 작업들을 수행하는 제어 흐름 구조로, 열거형의 배리언트에 따라 다른 코드를 실행하고, 매칭되는 값의 내부 데이터를 코드에서 사용할 수 있게 해준다.
