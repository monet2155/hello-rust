## 소유권

- 소유권은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음
- 컴파일러가 컴파일 중에 검사할 여러 규칙을 기반으로 메모리를 관리 (체크리스트같은 느낌)
- 규칙 중 하나라도 위반하면 컴파일되지 않음
- 주요 목표는 힙 데이터의 관리

### 소유권 규칙

- 각각의 값은 소유자(owner)가 정해져 있다.
- 한 값의 소유자는 동시에 여럿일 수 없다.
- 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다(dropped).

### 변수의 스코프

- 스코프란 아이템이 유효한 범위

```rust
{                      // s는 아직 선언되지 않아서 여기서는 유효하지 않습니다
    let s = "hello";   // 이 지점부터 s가 유효합니다

    // s로 어떤 작업을 합니다
}                      // 이 스코프가 종료되었고, s가 더 이상 유효하지 않습니다
```

### String 타입

- String 타입은 힙에 저장되기 때문에 Rust의 데이터 정리 과정을 알아보는데 적합함.
- 여태까지는 문자열을 하드코딩하는 문자열 리터럴을 사용했지만, 문자열 리터럴은 불변성을 지니기에 변경할 수 없음.

String 타입은 아래와 같이 `from` 함수와 문자열 리터럴을 이용해 생성 가능

```rust
let s = String::from("Hello");
```

아래 String 문자열은 변경이 가능함 (위는 immutable)

```rust
let mut s = String::from("hello");
s.push_str(", world!");
```

위 코드를 보았을때 String 또한 문자열 리터럴을 사용하여 생성하는데, 문자열 리터럴과 String은 어떤 차이가 있기에 변경할 수 있거나 없는지?

=> 각 타입의 메모리 사용 방식에 있음.

### 메모리와 할당

- 문자열 리터럴은 컴파일 타임에 내용을 알 수 있으므로, 최종 실행파일에 하드코딩 됨.
- 반면 String 타입은 힙에 메모리를 할당하기 때문에 텍스트 내용, 크기를 변경할 수 있는 것임. 반면 이 특징은 다음과 같은 현상을 유발함.
  - 실행 도중 메모리 할당자에게 메모리 할당을 요청해야함
  - String 사용을 마친 후 메모리를 해제할 방법이 필요함

첫 번째는 `String::from`을 호출 할 때 이미 해결됨

중요한 것은 두 번째, Rust에서는 이 문제를 스코프를 벗어나는 순간 자동으로 해제하도록 해결함.

```rust
{
    let mut s = String::from("hello");
    s.push_str(", world!");
}   // s 는 여기서 해제됨
```

Rust는 변수가 스코프 밖으로 벗어날 때 `drop` 이라는 특별한 함수를 호출함

`drop` 함수는 커스텀 타입을 개발한 개발자가 직접 메모리 해제 코드를 작성할 수 있게 함 (C++ 소멸자같은 개념)
